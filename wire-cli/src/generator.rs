use crate::parser::signature::ProviderSignature;

use std::collections::HashMap;

struct NameAllocator {
    used: HashMap<String, usize>,
    type_to_var: HashMap<String, String>,
}

impl NameAllocator {
    fn new() -> Self {
        Self {
            used: HashMap::new(),
            type_to_var: HashMap::new(),
        }
    }

    fn allocate(&mut self, type_name: &str) -> String {
        // Simple heuristic: "Config" -> "config", "DbPool" -> "db_pool"
        // If type_name is fully qualified "crate::a::Foo", extract "Foo".
        let base_ident = type_name.split("::").last().unwrap_or(type_name);
        let base = base_ident.to_lowercase(); 
        
        let count = self.used.entry(base.clone()).or_insert(0);
        let name = if *count == 0 {
            base.clone()
        } else {
            format!("{}_{}", base, count)
        };
        *count += 1;
        
        self.type_to_var.insert(type_name.to_string(), name.clone());
        name
    }

    fn get(&self, type_name: &str) -> String {
        self.type_to_var.get(type_name).cloned().unwrap_or_else(|| {
             // Fallback if input param wasn't allocated (should not happen in valid graph)
             type_name.to_lowercase()
        })
    }
}

pub fn generate(
    providers: Vec<ProviderSignature>,
    injector_name: &str,
    target_type: &str,
) -> String {
    let mut lines = Vec::new();
    let mut allocator = NameAllocator::new();

    for p in providers {
        let var_name = allocator.allocate(&p.output_type);
        
        let args = p
            .stripped_inputs
            .iter()
            .map(|t| format!("&{}", allocator.get(t)))
            .collect::<Vec<_>>()
            .join(", ");

        let call = if p.is_result {
            format!("let {} = {} ({}) ?;", var_name, p.full_path, args)
        } else {
            format!("let {} = {} ({});", var_name, p.full_path, args)
        };
        lines.push(call);
    }
    
    let target_var = allocator.get(target_type);

    format!(
        "// Code generated by wire-rs. DO NOT EDIT.\n\npub fn {}_generated() -> Result<{}, Box<dyn std::error::Error>> {{\n    {}\n    Ok({})\n}}",
        injector_name,
        target_type,
        lines.join("\n    "),
        target_var
    )
}
